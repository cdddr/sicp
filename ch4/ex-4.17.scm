;; When the procedure in the text's inner defines are interpreted sequentially, the bindings are added to the frame the lambda generated. The <e3> expression is then evaluated in the context of that frame. However, when the defines are scanned out into an enclosing let an additional frame is introduced because the let form creates a lambda which contains the bindings for the defines-now-lets. This difference won't matter to a correct program since the frame generated by the let form is the same as the expression which uses defines by the time <e3> is reached.

;; In order to implement simultaneous scope without the extra frame, the defines could be scanned out and bound along with the <vars> from the enclosing lambda. something like this:

(let ((u *unassigned-value*)
      (v *unassigned-value*)
      .
      .
      <vars>)
  <e3>)
